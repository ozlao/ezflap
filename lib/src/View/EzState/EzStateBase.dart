
import 'package:ezflap/src/Utils/Rx/RxWrapper/RxWrapper.dart';
import 'package:ezflap/src/Utils/Tick/Tick.dart';
import 'package:ezflap/src/Utils/Types/Types.dart';
import 'package:ezflap/src/View/EzState/ModelHandler/ModelHandler.dart';
import 'package:ezflap/src/View/EzStatefulWidget/EzStatefulWidgetBase.dart';
import 'package:flutter/widgets.dart';
import 'package:get/get.dart';
import 'package:meta/meta.dart';

enum _EzLifecycleState {
	created,
	mounted,
	initialized,
	ready,
	disposing,
	disposed,
}

/// This component should not be extended directly by application code. it is
/// meant to be extended by classes generated by the ezFlap framework. As such,
/// every ezFlap widget class implicitly extends it by extending the generated
/// _EzStateBase class.
/// This component and the generated _EzStateBase::
///  * render the widgets the application code has specified in ZML
///  * call hooks during certain points of the widget's lifecycle
///  * provide utilities, such as show an initial ZML while initializing and
///    automatically switch to the primary ZML when done, allow to register
///    callbacks to dispose of resources when the widget is disposed, and more.
///
/// Hooks are empty functions that are meant to be overridden by application
/// code, as necessary. They begin with a "hook" prefix and so are easy to
/// find and identify.
@internal
abstract class EzStateBase<T extends EzStatefulWidgetBase> extends State<T> {
	// we need this so that Obx() always have at least this one observable
	// (because GetX throws error when Obx() wraps code that doesn't access any
	// observable).
	var _dummy = 42.obs;

	static int _nextGuid = 1;

	@internal
	int $ezStateGuid = EzStateBase._nextGuid++;

	List<VoidCallback> _arrOnDisposeCallbacks = [ ];
	Rx<_EzLifecycleState> _ezLifecycleState = _EzLifecycleState.created.obs;
	bool _ezLifecycleReachedReady = false;
	TFuncCancel? _funcCancelRefreshProps;

	EzStateBase() {
		this.$initDI();
	}

	@override
	void initState() {
		super.initState();
		if (this.widget.$hasWidgetWrapper()) {
			Map<String, dynamic>? mapDIOverrides = this.widget.$getDIOverrides();
			if (mapDIOverrides != null) {
				// re-init
				this.$initDI(mapDIOverrides);
			}
		}

		this._ezLifecycleState.value = _EzLifecycleState.mounted;
		this.$internalInitState();
		this.hookInitState();
		this._ezLifecycleState.value = _EzLifecycleState.initialized;
		this.widget.funcNotifyInitState?.call(this);

		TFuncCancel funcCancel;
		funcCancel = Tick.nextTick(() async {
			// we will wait one more tick because refs need another tick to
			// be applied (from _INITIAL_ZML).
			funcCancel = Tick.nextTick(() async {
				await this.hookPrepare();

				// and now, one more tick for _ZML refs.
				funcCancel = Tick.nextTick(() async {
					this._ezLifecycleState.value = _EzLifecycleState.ready;
					this._ezLifecycleReachedReady = true;
					this.$internalOnReady();
					await this.hookReady();
				});
			});
		});

		// in case the Widget is disposed immediately after creation (e.g. in tests)
		this.onDispose(funcCancel);
	}

	@override
	void didUpdateWidget(covariant T oldWidget) {
		super.didUpdateWidget(oldWidget);

		if (this._funcCancelRefreshProps != null) {
			this._funcCancelRefreshProps!();
			this._funcCancelRefreshProps = null;
		}

		this._funcCancelRefreshProps = Tick.nextTick(() {
			this._funcCancelRefreshProps = null;
			this.$internalRefreshProps();
		});
	}

	/// Should not be overridden or used by application code
	@protected
	@nonVirtual
	@internal
	bool $isReady() {
		return (this._ezLifecycleState.value == _EzLifecycleState.ready);
	}

	/// Should not be overridden or used by application code
	@protected
	@nonVirtual
	@internal
	bool $hasReachedReadyNowOrBefore() {
		return this._ezLifecycleReachedReady;
	}


	/// Should not be overridden or used by application code
	@protected
	@internal
	void $internalInitState();


	/// Should not be overridden or used by application code
	@protected
	@internal
	void $internalOnReady();


	/// Should not be overridden or used by application code
	@protected
	@internal
	void $internalRefreshProps() { }


	/// Should not be overridden by application code
	@override
	@nonVirtual
	Widget build(BuildContext context) {
		Widget widget = Obx(() {
			// this is needed in case there are no observables in the widgets
			// themselves (because in such scenario GetX.Obx crashes)
			_dummy++;

			if (!this.$isReady()) {
				// not ready yet. try to get an Initial Widget
				Widget? widget = this.hookBuildInitialWidget();
				if (widget != null) {
					// found one. return it without invoking the "regular" build.
					return widget;
				}

				// no Initial Widget, but there may still be an _INITIAL_ZML
				// constant; if there is one - it will be handled by
				// this.$internalBuild() (and if there isn't - then $internalBuild
				// will make a Widget from the primary ZML as it does when we're
				// in _EzLifecycleState.ready.
			}

			return this.$internalBuild(context);
		});
		return widget;
	}


	/// Should not be overridden by application code
	@protected
	@internal
	Widget $internalBuild(BuildContext context);


	/// Call this function to register a callback to be called when disposing
	/// (i.e. when [State.dispose] is called).
	///  * the registered callbacks will be invoked in reverse order (i.e. the
	///    last registered callback will be invoked first).
	///  * the callbacks are invoked after [hookDispose] is called.
	@protected
	@nonVirtual
	void onDispose(VoidCallback func) {
		this._arrOnDisposeCallbacks.add(func);
	}

	@override
	void dispose() {
		super.dispose();

		this._ezLifecycleState.value = _EzLifecycleState.disposing;
		this._funcCancelRefreshProps?.call();
		this.widget.funcNotifyDispose?.call(this);
		this.hookDispose();
		this._arrOnDisposeCallbacks.reversed.forEach((func) => func());
		this._ezLifecycleState.value = _EzLifecycleState.disposed;
	}


	/// Called during [State.initState], after initializing all EzField with
	/// their default values.
	///  * particularly useful to initialize late EzField that are not defined
	///    with a default value. However, such EzField do not have to be
	///    initialized in this function; they can be initialized at any future
	///    time, as long as they are not accessed explicitly or implicitly (e.g.
	///    via an @EzComputed that is accessed from the ZML).
	@protected
	@visibleForOverriding
	void hookInitState() { }


	/// Called during [State.dispose] before the registered dispose callbacks
	/// (see [onDispose]) are invoked.
	@protected
	@visibleForOverriding
	void hookDispose() { }


	/// Called shortly after [hookInitState].
	///  * put asynchronous initializations here.
	///  * this can also be used for synchronous initializations, but not
	///    for initializations that the ZML (in its "initial" form) depends on,
	///    because [State.build] may run before this hook is invoked.
	///  * see [hookBuildInitialWidget] for more info on this
	///    delayed-initialization technique.
	@protected
	@visibleForOverriding
	Future<void> hookPrepare() async { }


	/// Called immediately after [hookPrepare] returns.
	///  * this hook is invoked after the initial ZML is replaced with the
	///    primary ZML.
	///  * this is a good place to put any additional initializations or
	///    actions the ZML doesn't depend on.
	@protected
	@visibleForOverriding
	Future<void> hookReady() async { }


	/// Called right after [hookInitState], to give the application code a
	/// chance to provide an alternative Widget to render while the widget is
	/// being initialized.
	///
	/// This is useful when the primary ZML relies on data that requires a
	/// delayed initialization.
	/// For example - data that needs to be downloaded from the internet.
	///
	/// When an initial widget is provided, either by this function or by
	/// providing initial ZML in an _INITIAL_ZML constant in the widget class -
	/// it is displayed instead of the primary ZML until [hookPrepare] returns.
	///
	/// If this hook returns a non-null value then the _INITIAL_ZML constant is
	/// ignored.
	///
	/// Example for using [hookBuildInitialWidget]:
	///
	/// ```dart
	/// @EzWidget()
    /// class HomeState extends _EzStateBase {
    ///   Widget? hookBuildInitialWidget() => Container(child: Text("Loading..."));
    ///
    ///   static const String _ZML = """
    ///     <Container>
    ///       <Text>Loaded!</Text>
    ///     </Container>
    ///   """
    /// }
	/// ```
    ///
    /// Example for using _INITIAL_ZML:
	///
	/// ```dart
	/// @EzWidget()
    /// class HomeState extends _EzStateBase {
    ///   static const String _INITIAL_ZML = """
    ///     <Container>
    ///       <Text>Loading...</Text>
    ///     </Container>
    ///   """
    ///
    ///   static const String _ZML = """
    ///     <Container>
    ///       <Text>Loaded!</Text>
    ///     </Container>
    ///   """
    /// }
	/// ```
    ///
    /// It is possible to initialize _INITIAL_ZML from a global constant (to
    /// have consistent behavior across multiple widgets without effort), or
    /// to use one of the built-in ZML snippets provided by this component,
	/// for example:
	///
	/// ```dart
	/// @EzWidget()
    /// class HomeState extends _EzStateBase {
    ///   static const String _INITIAL_ZML = INITIAL_ZML_LOADING;
    ///
    ///   static const String _ZML = """
    ///     <Container>
    ///       <Text>Loaded!</Text>
    ///     </Container>
    ///   """
    /// }
	/// ```
	@protected
	@visibleForOverriding
	Widget? hookBuildInitialWidget() {
		return null;
	}

	/// Should not be used by application code
	@internal
	static List<T> $autoMapper<T>(dynamic dyn, T? Function(dynamic value, dynamic key, dynamic keyOrIdx) func) {
		List<T> arrRet = [ ];

		if (dyn is Rx) {
			dyn = dyn.value;
		}

		if (dyn is List) {
			for (int i = 0; i < dyn.length; i++) {
				var result = func(dyn[i], i, null);
				if (result != null) {
					arrRet.add(result);
				}
			}
		}
		else if (dyn is Set) {
			int i = 0;
			for (dynamic value in dyn) {
				var result = func(value, i, null);
				if (result != null) {
					arrRet.add(result);
				}
				i++;
			}
		}
		else if (dyn is Map) {
			int i = 0;
			for (MapEntry kvp in dyn.entries) {
				var result = func(kvp.value, kvp.key, i);
				if (result != null) {
					arrRet.add(result);
				}
				i++;
			}
		}

		return arrRet;
	}

	@nonVirtual
	@internal
	$ModelHandler<U>? $tryGetModelHandler<U>(String key) {
		return this.widget.$tryGetModelHandler(key);
	}

	@nonVirtual
	@internal
	$ModelHandler<U> $getModelHandler<U>(String key, bool useDummyModelIfNotProvidedByHostWidget) {
		$ModelHandler<U>? modelHandler = this.$tryGetModelHandler<U>(key);
		if (modelHandler == null) {
			// the host component didn't provide a model. create a local one
			if (useDummyModelIfNotProvidedByHostWidget) {
				modelHandler = this._getOrMakeBackupModelHandler<U>(key);
			}
			else {
				throw "Mandatory model [${key}] not provided to Widget [${this}]";
			}
		}

		return modelHandler;
	}

	@nonVirtual
	@internal
	bool $hasModelHandler(String key) {
		return (this.widget.$tryGetModelHandler(key) != null);
	}

	@protected
	@nonVirtual
	@internal
	T $getRouteParam<T>(String key) {
		if (this.widget.$hasWidgetWrapper()) {
			return this.widget.$getRouteParamFromWidgetWrapper(key);
		}

		ModalRoute? modelRoute = ModalRoute.of(this.context);
		if (modelRoute == null) {
			throw "Cannot access ModalRoute.of(this.context) in ${this} for key [${key}]";
		}

		Object? args = modelRoute.settings.arguments;
		if (args is! Map<String, dynamic>) {
			throw "Provided arguments are not a Map<String, dynamic> in ${this} for key [${key}]. They are: ${args}";
		}

		Map<String, dynamic> map = args;
		return map[key] as T;
	}

	@protected
	@nonVirtual
	@internal
	T $tryGetRouteParam<T>(String key, T defaultValue) {
		if (this.widget.$hasWidgetWrapper()) {
			return this.widget.$getRouteParamFromWidgetWrapper(key);
		}

		ModalRoute? modelRoute = ModalRoute.of(this.context);
		if (modelRoute == null) {
			throw "Cannot access ModalRoute.of(this.context) in ${this} for key [${key}]";
		}

		Object? args = modelRoute.settings.arguments;
		if (args == null || args is! Map<String, dynamic>) {
			return defaultValue;
		}

		Map<String, dynamic> map = args;
		if (!map.containsKey(key)) {
			return defaultValue;
		}

		return map[key] as T;
	}

	Map<String, $ModelHandler>? _mapBackupModelHandlers;
	$ModelHandler<U>? _tryGetBackupModelHandler<U>(String key) {
		if (this._mapBackupModelHandlers == null) {
			return null;
		}
		return this._mapBackupModelHandlers![key] as $ModelHandler<U>?;
	}

	$ModelHandler<U> _getOrMakeBackupModelHandler<U>(String key) {
		$ModelHandler<U>? modelHandler = this._tryGetBackupModelHandler(key);
		if (modelHandler == null) {
			if (this._mapBackupModelHandlers == null) {
				this._mapBackupModelHandlers = { };
			}

			RxWrapper<U> rxWrapper = RxWrapper<U>();
			modelHandler = $ModelHandler(
				funcSetModelValue: (U value) { rxWrapper.setValue(value); },
				funcGetModelValue: () => rxWrapper.getValue(),
			);
			this._mapBackupModelHandlers![key] = modelHandler;
		}
		return modelHandler;
	}

	/// Should not be used by application code
	@internal
	static bool $testAttr(dynamic expected, dynamic actual) {
		if (expected == null && actual == null) {
			return true;
		}

		if (expected == null || actual == null) {
			return false;
		}

		if (expected.runtimeType == actual.runtimeType) {
			return (expected == actual);
		}

		return false;
	}

	@internal
	EzStatefulWidgetBase $instantiateOrMock(String key, Function funcInstantiate) {
		return this.widget.$tryMockWidget(key) ?? funcInstantiate();
	}

	@protected
	@internal
	void $initDI([ Map<String, dynamic>? mapOverrides ]) { }

	/// Full documentation: https://www.ezflap.io/advanced/interpolated-text/interpolated-text.html
	@protected
	@nonVirtual
	String? tryGetInterpolatedText() {
		return this.widget.$tryGetInterpolatedText();
	}

	/// Full documentation: https://www.ezflap.io/advanced/interpolated-text/interpolated-text.html
	@protected
	@nonVirtual
	String getInterpolatedText() {
		return this.tryGetInterpolatedText()!;
	}
	
	/// Full documentation: https://www.ezflap.io/deep-dive/events/events.html
	///
	/// Use this method to check whether a particular emit handler is available
	/// (i.e. if one was provided by the host widget using `z-on`).
	@protected
	@nonVirtual
	bool hasEmitHandler(String emitKey) {
		return (this.widget.$tryGetEmitHandler(emitKey) != null);
	}
}
